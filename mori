local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local enemies = workspace.__Main.__Enemies.Server

local mapId = "7"
local targetMap = enemies:FindFirstChild(mapId)
if not targetMap then
    warn("Không tìm thấy map: " .. mapId)
    return
end

local speed = 1000
local tween = nil
local isBusy = false

-- Tìm mob gần nhất còn sống và có Scale = 2
local function findNearestMob()
    local nearest, minDist = nil, math.huge
    for _, mob in pairs(targetMap:GetChildren()) do
        local hp = mob:GetAttribute("HP")
        local scale = mob:GetAttribute("Scale")
        if hp and hp > 0 and scale == 2 then
            local dist = (mob.Position - rootPart.Position).Magnitude
            if dist < minDist then
                minDist, nearest = dist, mob
            end
        end
    end
    return nearest
end

-- Gửi lệnh tiêu diệt mob
local function destroyMob(uuid)
    for i = 1, 5 do
        local args = {
            [1] = {
                [1] = {
                    ["Event"] = "EnemyDestroy",
                    ["Enemy"] = uuid
                },
                [2] = "\4"
            }
        }
        ReplicatedStorage.BridgeNet2.dataRemoteEvent:FireServer(unpack(args))
    end
end

-- Tween tới mob
local function moveToMob(mob)
    if not mob or not mob.Parent then 
        isBusy = false 
        return 
    end

    local uuid = mob:GetAttribute("UUID") or mob.Name
    local hp = mob:GetAttribute("HP")
    local scale = mob:GetAttribute("Scale")
    if not hp or hp <= 0 or scale ~= 2 then 
        isBusy = false 
        return 
    end

    isBusy = true
    if tween then tween:Cancel() end
    rootPart.CanCollide = false

    local offset = (mob.Position - rootPart.Position).Unit * -4
    local targetPosition = mob.Position + offset + Vector3.new(0, 3, 0)
    local distance = (targetPosition - rootPart.Position).Magnitude
    local tweenTime = math.max(distance / speed, 0.1)

    tween = TweenService:Create(rootPart, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {
        CFrame = CFrame.new(targetPosition, mob.Position)
    })
    tween:Play()

    local connection
    connection = RunService.Heartbeat:Connect(function()
        -- Nếu mob không còn tồn tại, hủy connection và tween
        if not mob or not mob.Parent then
            connection:Disconnect()
            if tween then tween:Cancel() end
            isBusy = false
            return
        end

        -- Nếu mob chết, hủy tween và thực hiện tiêu diệt mob
        local currentHP = mob:GetAttribute("HP")
        if not currentHP or currentHP <= 0 then
            connection:Disconnect()
            if tween then tween:Cancel() end
            task.spawn(function()
                destroyMob(uuid)
            end)

            -- Tìm mob tiếp theo và move tới đó
            local nextMob = findNearestMob()
            if nextMob then
                moveToMob(nextMob)
            else
                isBusy = false
            end
        end
    end)

    -- Kiểm tra nếu tween hoàn thành, đảm bảo mob còn sống
    tween.Completed:Connect(function()
        -- Nếu mob còn sống khi đến nơi, tiếp tục theo dõi
        if mob and mob.Parent then
            local currentHP = mob:GetAttribute("HP")
            if currentHP and currentHP > 0 then
                -- Đợi đến khi nó chết rồi xử lý
                return
            end
        end

        -- Nếu mob đã chết khi đến nơi thì gọi mob khác
        local nextMob = findNearestMob()
        if nextMob then
            moveToMob(nextMob)
        else
            isBusy = false
        end
    end)
end

-- Vòng lặp chính
while true do
    task.wait(0.1)
    if not isBusy then
        local mob = findNearestMob()
        if mob then
            moveToMob(mob)
        end
    end
end
